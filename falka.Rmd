---
title: "Eksploracja Danych Masywnych: Projekt I"
author: "Sebastian Michoń 136770, Grzegorz Kaszuba 133???"
output: html_document
---

<br/>
Wykorzystane biblioteki:
```{r}
library(ggplot2) #Do tworzenia regularnych wykresów
library(plotly) #Do tworzenia interaktywnych wykresów
library(dplyr) #Do manipulacji na danych
library(magrittr) #Dla operatora %>%
library(caTools)
library(reshape2) #Dla funkcji 'melt' upraszczającej stworzenie heatmapy korelacji
```
Wymuszanie identycznych rezultatów dla kolejnych wywołań i wczytanie danych:
```{r}
set.seed(2112) #Zadbanie o taki sam rezultat dla kolejnych wywołań
data <- read.csv('Life_Expectancy_Data.csv')
```

```{r}
sum_nas <- function(x, na.rm){
    sum(is.na(x))
}
statistics <- list(list('Nothing_to_see_here', "Column name"), 
                   list(mean, "Mean"), list(sd, "Standard Deviation"),
                   list(min, "Minimum"), list(max, "Maximum"),
                  list(median, "Median"), list(sum_nas, "Amount of NaN"))

all_cols = list()
for (x in statistics){
    all_cols[[length(all_cols)+1]] <- x[[2]]
}

df_summary <- data.frame(matrix(ncol = length(all_cols), nrow = 0))
colnames(df_summary) <- all_cols
```

```{r}
cols <- ncol(data)
cat("Number of rows: ", nrow(data), "\nNumber of columns: ", cols, "\n")
ite <- 1

for (x in data){
    
    dist = "   "
    if (class(x) != 'factor'){
        new_row <- list()
        for (y in statistics){
            if (y[[2]] == 'Column name')
                new_row[[length(new_row)+1]] <- colnames(data)[ite]
            else
                new_row[[length(new_row)+1]] <- y[[1]](x, na.rm=TRUE)
        }
        df_summary[nrow(df_summary) + 1, ] <- new_row
    }
    else{
        names <- unique(x)
        cat('\nFactor column: ', colnames(data)[ite], ', Unique values: ', paste(shQuote(names, type="cmd"), collapse=", "), '\n')
    }
    ite <- ite+1
}
```



Zadbanie o to, aby wykresy były niesamowicie eleganckie:
```{r}
options(repr.plot.width=24, repr.plot.height=16)
```
Tworzenie eleganckich wykresów rozkładu zmiennych: warto zwrócić uwagę na wykorzystanie density-plotu dla danych ciągłych i barplota dla danych dyskretnych. Uwzględniono - dla kompletności - rozkład lat i krajów.
```{r}
for (x in colnames(data)){
    if (is.numeric(data[[x]]) && x!='Year')
        print(data %>%
              filter(!is.na(data[[x]])) %>%
              ggplot(aes_string(x=x)) + geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8))
    else
        print(data %>%
              filter(!is.na(data[[x]])) %>%
              ggplot(aes_string(x=x)) + geom_bar() + 
                  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 6, hjust = 1)))
}
```

Dodatkowe wykresy prezentujący korelacje pomiędzy Life.expectancy a pozostałymi zmiennymi: pozwalają one zauważyć, że dla pewne wartości mogły nie zostać poprawnie udokumentowane
```{r}
for (x in colnames(data)){
    if (x == 'Life.expectancy')
        next
    plot_data <- data %>% filter(!is.na(data[[x]]) & !is.na(data[['Life.expectancy']]))
    plot_itself <- plot_data %>% ggplot(aes_string(x=x, y='Life.expectancy')) + geom_point()
    if (x == 'Country')
        plot_itself <- plot_itself + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 6, hjust = 1))
    print(plot_itself)
}
```

Heatmapa przedstawiająca korelacje między zmiennymi:
```{r}
cor_matrix <- data %>% select(-c(Country, Status)) %>% cor(use = "complete.obs") %>% round(2)
melt_matrix <- melt(cor_matrix, na.rm = TRUE)

#Wzorzec I: https://r-charts.com/correlation/heat-map-ggplot2/
#Wzorzec II: http://sthda.com/english/wiki/ggplot2-quick-correlation-matrix-heatmap-r-software-and-data-visualization

ggplot(data = melt_matrix, aes(Var2, Var1, fill = value))+
    geom_tile()+
    scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
        midpoint = 0, limit = c(-1,1), space = "Lab", 
        name="Pearson\nCorrelation") +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, 
        size = 5, hjust = 1))+
    geom_text(aes(label = value), color = 'black', size = 1.5)+
    coord_fixed()
```

Preparacja danych do stworzenia interaktywnego wykresu długości życia w funkcji kraju i roku:
```{r}
unique_countries <- unique(data$Country)
buttons_countries <- list()

for (i in seq_along(unique_countries)){
    buttons_countries[[length(buttons_countries)+1]] <- list(method = "restyle",
               args = list("transforms[0].value", unique_countries[i]),
               label = unique_countries[i])
}
```
Wykres długości życia w funkcji kraju i roku:
```{r}
#Wzorzec: https://stackoverflow.com/questions/63906441/plotly-r-using-colour-and-transformation-with-a-line-plot
p <- data %>% filter(!is.na(Life.expectancy)) %>%
  plot_ly(
    type = 'scatter', 
    x = ~Year, 
    y = ~Life.expectancy,
    mode = 'markers',
    transforms = list(
      list(
        type = 'filter',
        target = ~Country,
        operation = '=',
        value = unique_countries[1]
      )
  )) %>% layout(
    updatemenus = list(
      list(
        type = 'dropdown',
        active = 0,
        buttons = buttons_countries
      )
    )
  )

p
```

Preparacja danych dla regresora
```{r}
change <- function(data, name, borderline, multiplier) {
    data[[name]][data[[name]] < borderline & !is.na(data[[name]])] <- data[[name]][data[[name]] < borderline & !is.na(data[[name]])]*multiplier
    data
}

data <- data %>% filter(!is.na(Life.expectancy))

data <- change(data, 'BMI', 8.5, 10)
data <- change(data, 'Diphtheria', 10, 10)

for (x in colnames(data)){
    if (data %>% filter(is.na(data[[x]])) %>% nrow == 0)
        next
    data[[paste(x, '_na', sep='')]] <- rep(0, nrow(data))
    data[[paste(x, '_na', sep='')]][is.na(data[[x]])]  <- 1
    mid = data[[x]]
    data[[x]][is.na(data[[x]])]  <- median(data[[x]], na.rm=TRUE)
}
```

Usunięcie powtarzających się kolumn:
```{r}
marked = 'Q'
while (marked != '-'){
    marked='-'
    for (x in colnames(data)){
        for (y in colnames(data)){
            if (!is.numeric(data[[x]]) || !is.numeric(data[[y]]) || x==y)
                next
            summa = ifelse (data[[x]] == data[[y]], 1, 0)
            if (sum(summa) == nrow(data)){
                marked = y
                break
            }
        }
        if (marked!='-') break
    }
    if (marked!='-')
        data <- data %>% select(-c(y))
}
```

Wykonanie regresora:
```{r}
tmp_data= sample.split(data, SplitRatio = 0.3)
train = subset(data,tmp_data==TRUE)
test = subset(data,tmp_data==FALSE)

lm_death <- train %>% select(-c(Country)) %>% lm(formula=Life.expectancy ~ .)
summary(lm_death)

pred <- predict(lm_death, test)
```

Wartość \(rmse\):
```{r}
sqrt(mean((pred - test$Life.expectancy)^2))
```

